<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Object Viewer - THREE.js + Anime.js</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0a0a0f;
            color: #fff;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* Control Panel */
        .control-panel {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 30, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 16px 24px;
            display: flex;
            gap: 24px;
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            opacity: 0;
            max-width: 95vw;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-section h3 {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #888;
            margin-bottom: 2px;
        }

        .button-group {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 7px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            white-space: nowrap;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .btn.active {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
        }

        .btn-play {
            background: linear-gradient(135deg, #10b981, #059669);
            min-width: 80px;
        }

        .btn-play:hover {
            background: linear-gradient(135deg, #34d399, #10b981);
        }

        .btn-object {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }

        .btn-object:hover {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
        }

        .btn-object.active {
            background: linear-gradient(135deg, #f59e0b, #b45309);
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            max-width: 300px;
            z-index: 1000;
            opacity: 0;
        }

        .info-panel h1 {
            font-size: 18px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #6366f1, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .info-panel p {
            font-size: 12px;
            color: #aaa;
            line-height: 1.5;
        }

        .info-panel .tech-stack {
            margin-top: 12px;
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .tech-tag {
            background: rgba(99, 102, 241, 0.2);
            color: #a5b4fc;
            padding: 3px 8px;
            border-radius: 20px;
            font-size: 10px;
        }

        /* Animation indicator */
        .animation-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 11px;
            color: #888;
            z-index: 1000;
            opacity: 0;
        }

        .animation-indicator .status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            animation: pulse 1.5s infinite;
        }

        .status-dot.animating {
            background: #f59e0b;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Loading screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0f;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #6366f1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading-text {
            margin-top: 20px;
            color: #888;
            font-size: 14px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loading">
        <div class="loader"></div>
        <p class="loading-text">Loading 3D Scene...</p>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Info Panel -->
    <div class="info-panel" id="info-panel">
        <h1 id="object-title">ü´ñ Teapot</h1>
        <p id="object-desc">Classic teapot with decorative decals, gold metallic accents, and procedural textures.</p>
        <div class="tech-stack">
            <span class="tech-tag">THREE.js</span>
            <span class="tech-tag">Anime.js</span>
            <span class="tech-tag">PBR Materials</span>
        </div>
    </div>

    <!-- Animation Indicator -->
    <div class="animation-indicator" id="indicator">
        <div class="status">
            <div class="status-dot" id="status-dot"></div>
            <span id="status-text">Ready</span>
        </div>
    </div>

    <!-- Control Panel -->
    <div class="control-panel" id="control-panel">
        <div class="control-section">
            <h3>Object</h3>
            <div class="button-group">
                <button class="btn btn-object active" data-object="teapot">ü´ñ Teapot</button>
                <button class="btn btn-object" data-object="table">ü™ë Table</button>
                <button class="btn btn-object" data-object="crystal">üîÆ Crystal</button>
                <button class="btn btn-object" data-object="earth">üåç Earth</button>
                <button class="btn btn-object" data-object="solar">‚òÄÔ∏è Solar</button>
                <button class="btn btn-object" data-object="microbes">ü¶† Microbes</button>
            </div>
        </div>

        <div class="control-section">
            <h3>Camera</h3>
            <div class="button-group">
                <button class="btn active" data-camera="front">Front</button>
                <button class="btn" data-camera="top">Top</button>
                <button class="btn" data-camera="side">Side</button>
                <button class="btn" data-camera="orbit">Orbit</button>
                <button class="btn" data-camera="closeup">Close</button>
            </div>
        </div>

        <div class="control-section">
            <h3>Lighting</h3>
            <div class="button-group">
                <button class="btn active" data-lighting="studio">Studio</button>
                <button class="btn" data-lighting="soft">Soft</button>
                <button class="btn" data-lighting="product">Product</button>
                <button class="btn" data-lighting="sunset">Sunset</button>
                <button class="btn" data-lighting="neon">Neon</button>
                <button class="btn" data-lighting="space">Space</button>
            </div>
        </div>

        <div class="control-section">
            <h3>Play</h3>
            <div class="button-group">
                <button class="btn btn-play" id="play-btn">‚ñ∂ Animate</button>
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/examples/js/controls/OrbitControls.js"></script>

    <!-- Anime.js -->
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.min.js"></script>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================

        const CONFIG = {
            camera: {
                front: { position: [0, 2, 8], target: [0, 0, 0] },
                top: { position: [0, 12, 0.1], target: [0, 0, 0] },
                side: { position: [10, 2, 0], target: [0, 0, 0] },
                orbit: { position: [5, 4, 5], target: [0, 0, 0] },
                closeup: { position: [2, 1, 3], target: [0, 0.3, 0] }
            },
            lighting: {
                studio: {
                    ambient: { color: 0xffffff, intensity: 0.4 },
                    key: { color: 0xffffff, intensity: 1.2, position: [5, 5, 5] },
                    fill: { color: 0x8888ff, intensity: 0.4, position: [-5, 3, 0] },
                    rim: { color: 0xffaa00, intensity: 0.6, position: [0, 3, -5] },
                    background: 0x1a1a2e
                },
                soft: {
                    ambient: { color: 0xfff5e6, intensity: 0.5 },
                    key: { color: 0xfff0dd, intensity: 1.0, position: [3, 6, 3] },
                    fill: { color: 0xfff0dd, intensity: 0.6, position: [-3, 4, 3] },
                    rim: { color: 0xffffff, intensity: 0.3, position: [0, 2, -4] },
                    background: 0x2a2a3e
                },
                product: {
                    ambient: { color: 0xffffff, intensity: 0.6 },
                    key: { color: 0xffffff, intensity: 1.5, position: [0, 8, 4] },
                    fill: { color: 0xeeeeff, intensity: 0.5, position: [-4, 3, 4] },
                    rim: { color: 0xffffff, intensity: 0.8, position: [4, 3, -3] },
                    background: 0xf0f0f5
                },
                sunset: {
                    ambient: { color: 0xff8844, intensity: 0.3 },
                    key: { color: 0xff6600, intensity: 1.5, position: [-5, 2, 5] },
                    fill: { color: 0x4400ff, intensity: 0.3, position: [5, 3, -3] },
                    rim: { color: 0xff0044, intensity: 0.8, position: [0, 5, -5] },
                    background: 0x1a0a1e
                },
                neon: {
                    ambient: { color: 0x220033, intensity: 0.2 },
                    key: { color: 0xff00ff, intensity: 1.2, position: [4, 4, 4] },
                    fill: { color: 0x00ffff, intensity: 0.8, position: [-4, 3, 2] },
                    rim: { color: 0xffff00, intensity: 0.6, position: [0, 2, -5] },
                    background: 0x0a0015
                },
                space: {
                    ambient: { color: 0x111122, intensity: 0.1 },
                    key: { color: 0xffffee, intensity: 2.0, position: [10, 5, 5] },
                    fill: { color: 0x222244, intensity: 0.2, position: [-5, 0, 0] },
                    rim: { color: 0x4444ff, intensity: 0.3, position: [0, -5, -5] },
                    background: 0x000008
                }
            },
            objects: {
                teapot: { title: 'ü´ñ Teapot', desc: 'Classic teapot with decorative decals, gold metallic accents, and procedural textures.' },
                table: { title: 'ü™ë Table', desc: 'Wooden dining table with detailed wood grain texture and metal fixtures.' },
                crystal: { title: 'üîÆ Crystal Ball', desc: 'Mystical crystal ball with internal glow, caustics, and magical particles.' },
                earth: { title: 'üåç Earth', desc: 'Planet Earth with atmosphere, clouds layer, and city lights on the night side.' },
                solar: { title: '‚òÄÔ∏è Solar System', desc: 'Miniature solar system with orbiting planets and asteroid belt.' },
                microbes: { title: 'ü¶† Microbes', desc: 'Microscopic organisms floating in a petri dish environment.' }
            }
        };

        // ============================================
        // GLOBALS
        // ============================================

        let scene, camera, renderer, controls;
        let currentObject = null;
        let currentObjectType = 'teapot';
        let ambientLight, keyLight, fillLight, rimLight;
        let isAnimating = false;
        let autoRotate = true;
        let animationMixers = [];

        // ============================================
        // THREE.JS SCENE SETUP
        // ============================================

        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(CONFIG.lighting.studio.background);

            camera = new THREE.PerspectiveCamera(
                45,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(...CONFIG.camera.front.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0);

            createLights();
            createFloor();
            createObject('teapot');

            window.addEventListener('resize', onWindowResize);
        }

        function createLights() {
            ambientLight = new THREE.AmbientLight(
                CONFIG.lighting.studio.ambient.color,
                CONFIG.lighting.studio.ambient.intensity
            );
            scene.add(ambientLight);

            keyLight = new THREE.DirectionalLight(
                CONFIG.lighting.studio.key.color,
                CONFIG.lighting.studio.key.intensity
            );
            keyLight.position.set(...CONFIG.lighting.studio.key.position);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            keyLight.shadow.camera.near = 0.5;
            keyLight.shadow.camera.far = 50;
            keyLight.shadow.camera.left = -10;
            keyLight.shadow.camera.right = 10;
            keyLight.shadow.camera.top = 10;
            keyLight.shadow.camera.bottom = -10;
            scene.add(keyLight);

            fillLight = new THREE.PointLight(
                CONFIG.lighting.studio.fill.color,
                CONFIG.lighting.studio.fill.intensity
            );
            fillLight.position.set(...CONFIG.lighting.studio.fill.position);
            scene.add(fillLight);

            rimLight = new THREE.PointLight(
                CONFIG.lighting.studio.rim.color,
                CONFIG.lighting.studio.rim.intensity
            );
            rimLight.position.set(...CONFIG.lighting.studio.rim.position);
            scene.add(rimLight);
        }

        function createFloor() {
            const floorGeometry = new THREE.CircleGeometry(15, 64);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x222233,
                metalness: 0.5,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -1.5;
            floor.receiveShadow = true;
            floor.name = 'floor';
            scene.add(floor);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============================================
        // OBJECT CREATORS
        // ============================================

        function createObject(type) {
            // Remove existing object
            if (currentObject) {
                scene.remove(currentObject);
                currentObject = null;
            }
            animationMixers = [];

            currentObjectType = type;

            switch (type) {
                case 'teapot':
                    currentObject = createTeapot();
                    break;
                case 'table':
                    currentObject = createTable();
                    break;
                case 'crystal':
                    currentObject = createCrystalBall();
                    break;
                case 'earth':
                    currentObject = createEarth();
                    break;
                case 'solar':
                    currentObject = createSolarSystem();
                    break;
                case 'microbes':
                    currentObject = createMicrobes();
                    break;
            }

            if (currentObject) {
                scene.add(currentObject);
            }

            // Update info panel
            document.getElementById('object-title').textContent = CONFIG.objects[type].title;
            document.getElementById('object-desc').textContent = CONFIG.objects[type].desc;
        }

        function createTeapot() {
            const group = new THREE.Group();

            // Create decorative texture
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createLinearGradient(0, 0, 512, 512);
            gradient.addColorStop(0, '#6366f1');
            gradient.addColorStop(0.5, '#8b5cf6');
            gradient.addColorStop(1, '#6366f1');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);

            // Floral pattern
            ctx.strokeStyle = '#c4b5fd';
            ctx.lineWidth = 2;
            for (let i = 0; i < 8; i++) {
                const x = 64 + (i % 4) * 128;
                const y = 64 + Math.floor(i / 4) * 256;
                ctx.beginPath();
                ctx.arc(x, y, 40, 0, Math.PI * 2);
                ctx.stroke();
                for (let j = 0; j < 6; j++) {
                    const angle = (j / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(x + Math.cos(angle) * 25, y + Math.sin(angle) * 25, 12, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            ctx.fillStyle = '#fbbf24';
            for (let i = 0; i < 30; i++) {
                ctx.beginPath();
                ctx.arc(Math.random() * 512, Math.random() * 512, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            const decalTexture = new THREE.CanvasTexture(canvas);

            const mainMaterial = new THREE.MeshPhysicalMaterial({
                map: decalTexture,
                metalness: 0.1,
                roughness: 0.3,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            });

            const metalMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffd700,
                metalness: 0.9,
                roughness: 0.2
            });

            // Body
            const bodyGeom = new THREE.SphereGeometry(1, 64, 64);
            bodyGeom.scale(1, 0.7, 1);
            const body = new THREE.Mesh(bodyGeom, mainMaterial);
            body.castShadow = true;
            group.add(body);

            // Lid
            const lidBase = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.5, 0.15, 32), metalMaterial);
            lidBase.position.y = 0.65;
            group.add(lidBase);

            const lid = new THREE.Mesh(new THREE.SphereGeometry(0.45, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2), mainMaterial);
            lid.position.y = 0.72;
            group.add(lid);

            const knob = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), metalMaterial);
            knob.position.y = 1.15;
            group.add(knob);

            // Spout
            const spout = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.15, 0.8, 16), mainMaterial);
            spout.position.set(1.0, 0.2, 0);
            spout.rotation.z = -Math.PI / 4;
            group.add(spout);

            const spoutTip = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.08, 0.2, 16), metalMaterial);
            spoutTip.position.set(1.35, 0.55, 0);
            spoutTip.rotation.z = -Math.PI / 4;
            group.add(spoutTip);

            // Handle
            const handle = new THREE.Mesh(new THREE.TorusGeometry(0.4, 0.08, 16, 32, Math.PI), metalMaterial);
            handle.position.set(-0.95, 0.2, 0);
            handle.rotation.set(0, Math.PI / 2, Math.PI / 2);
            group.add(handle);

            // Rim
            const rim = new THREE.Mesh(new THREE.TorusGeometry(0.6, 0.08, 16, 32), metalMaterial);
            rim.position.y = -0.6;
            rim.rotation.x = Math.PI / 2;
            group.add(rim);

            group.position.y = 0.5;
            return group;
        }

        function createTable() {
            const group = new THREE.Group();

            // Wood texture
            const woodCanvas = document.createElement('canvas');
            woodCanvas.width = 512;
            woodCanvas.height = 512;
            const wctx = woodCanvas.getContext('2d');

            wctx.fillStyle = '#8B4513';
            wctx.fillRect(0, 0, 512, 512);

            // Wood grain
            for (let i = 0; i < 50; i++) {
                wctx.strokeStyle = `rgba(60, 30, 10, ${Math.random() * 0.3})`;
                wctx.lineWidth = 1 + Math.random() * 3;
                wctx.beginPath();
                const y = Math.random() * 512;
                wctx.moveTo(0, y);
                for (let x = 0; x < 512; x += 20) {
                    wctx.lineTo(x, y + Math.sin(x * 0.02) * 10 + Math.random() * 5);
                }
                wctx.stroke();
            }

            // Knots
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const grad = wctx.createRadialGradient(x, y, 0, x, y, 20);
                grad.addColorStop(0, '#3d2817');
                grad.addColorStop(1, '#8B4513');
                wctx.fillStyle = grad;
                wctx.beginPath();
                wctx.ellipse(x, y, 15 + Math.random() * 10, 8 + Math.random() * 5, Math.random() * Math.PI, 0, Math.PI * 2);
                wctx.fill();
            }

            const woodTexture = new THREE.CanvasTexture(woodCanvas);
            woodTexture.wrapS = THREE.RepeatWrapping;
            woodTexture.wrapT = THREE.RepeatWrapping;

            const woodMaterial = new THREE.MeshStandardMaterial({
                map: woodTexture,
                roughness: 0.7,
                metalness: 0.0
            });

            const metalMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.3
            });

            // Table top
            const top = new THREE.Mesh(new THREE.BoxGeometry(3, 0.15, 2), woodMaterial);
            top.position.y = 1;
            top.castShadow = true;
            top.receiveShadow = true;
            group.add(top);

            // Legs
            const legGeom = new THREE.CylinderGeometry(0.08, 0.1, 2.3, 16);
            const legPositions = [[-1.3, -0.15, 0.8], [1.3, -0.15, 0.8], [-1.3, -0.15, -0.8], [1.3, -0.15, -0.8]];
            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeom, metalMaterial);
                leg.position.set(...pos);
                leg.castShadow = true;
                group.add(leg);
            });

            // Cross bars
            const barGeom = new THREE.CylinderGeometry(0.03, 0.03, 2.6, 8);
            const bar1 = new THREE.Mesh(barGeom, metalMaterial);
            bar1.rotation.z = Math.PI / 2;
            bar1.position.set(0, -0.5, 0.8);
            group.add(bar1);

            const bar2 = new THREE.Mesh(barGeom, metalMaterial);
            bar2.rotation.z = Math.PI / 2;
            bar2.position.set(0, -0.5, -0.8);
            group.add(bar2);

            group.position.y = 0;
            return group;
        }

        function createCrystalBall() {
            const group = new THREE.Group();

            // Crystal ball
            const crystalMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x8888ff,
                metalness: 0.0,
                roughness: 0.0,
                transmission: 0.95,
                thickness: 2,
                envMapIntensity: 1,
                clearcoat: 1,
                clearcoatRoughness: 0,
                ior: 2.0
            });

            const ball = new THREE.Mesh(new THREE.SphereGeometry(1.2, 64, 64), crystalMaterial);
            ball.castShadow = true;
            group.add(ball);

            // Inner glow
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x4444ff,
                transparent: true,
                opacity: 0.3
            });
            const innerGlow = new THREE.Mesh(new THREE.SphereGeometry(0.8, 32, 32), glowMaterial);
            group.add(innerGlow);

            // Magical particles inside
            const particleGeom = new THREE.BufferGeometry();
            const particleCount = 200;
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const r = Math.random() * 0.9;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = r * Math.cos(phi);
            }
            particleGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particleMat = new THREE.PointsMaterial({
                color: 0xaaaaff,
                size: 0.05,
                transparent: true,
                opacity: 0.8
            });
            const particles = new THREE.Points(particleGeom, particleMat);
            particles.name = 'particles';
            group.add(particles);

            // Stand
            const standMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a1a0a,
                metalness: 0.3,
                roughness: 0.7
            });

            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1, 0.3, 32), standMaterial);
            base.position.y = -1.4;
            base.castShadow = true;
            group.add(base);

            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.4, 32), standMaterial);
            stem.position.y = -1.1;
            group.add(stem);

            // Decorative claws
            const clawMat = new THREE.MeshStandardMaterial({ color: 0xcc9933, metalness: 0.8, roughness: 0.3 });
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const claw = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.5, 8), clawMat);
                claw.position.set(Math.cos(angle) * 0.5, -0.7, Math.sin(angle) * 0.5);
                claw.rotation.x = -0.3;
                claw.rotation.z = -angle;
                group.add(claw);
            }

            group.position.y = 0.5;
            return group;
        }

        function createEarth() {
            const group = new THREE.Group();

            // Earth texture (procedural)
            const earthCanvas = document.createElement('canvas');
            earthCanvas.width = 1024;
            earthCanvas.height = 512;
            const ectx = earthCanvas.getContext('2d');

            // Ocean
            ectx.fillStyle = '#1a4d7c';
            ectx.fillRect(0, 0, 1024, 512);

            // Continents (simplified)
            ectx.fillStyle = '#3d8c40';
            // Americas
            ectx.beginPath();
            ectx.ellipse(250, 200, 80, 120, 0.2, 0, Math.PI * 2);
            ectx.fill();
            ectx.beginPath();
            ectx.ellipse(280, 350, 50, 80, -0.3, 0, Math.PI * 2);
            ectx.fill();
            // Europe/Africa
            ectx.beginPath();
            ectx.ellipse(550, 180, 60, 50, 0, 0, Math.PI * 2);
            ectx.fill();
            ectx.beginPath();
            ectx.ellipse(550, 300, 70, 100, 0.1, 0, Math.PI * 2);
            ectx.fill();
            // Asia
            ectx.beginPath();
            ectx.ellipse(750, 180, 150, 80, 0, 0, Math.PI * 2);
            ectx.fill();
            // Australia
            ectx.beginPath();
            ectx.ellipse(850, 350, 50, 40, 0.3, 0, Math.PI * 2);
            ectx.fill();

            // Add some terrain variation
            ectx.fillStyle = '#2d6a30';
            for (let i = 0; i < 50; i++) {
                ectx.beginPath();
                ectx.arc(Math.random() * 1024, Math.random() * 512, 10 + Math.random() * 30, 0, Math.PI * 2);
                ectx.fill();
            }

            const earthTexture = new THREE.CanvasTexture(earthCanvas);

            const earthMaterial = new THREE.MeshStandardMaterial({
                map: earthTexture,
                roughness: 0.8,
                metalness: 0.1
            });

            const earth = new THREE.Mesh(new THREE.SphereGeometry(1.5, 64, 64), earthMaterial);
            earth.name = 'earth';
            earth.castShadow = true;
            group.add(earth);

            // Clouds layer
            const cloudCanvas = document.createElement('canvas');
            cloudCanvas.width = 512;
            cloudCanvas.height = 256;
            const cctx = cloudCanvas.getContext('2d');
            cctx.fillStyle = 'rgba(0,0,0,0)';
            cctx.fillRect(0, 0, 512, 256);
            cctx.fillStyle = 'rgba(255,255,255,0.6)';
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 256;
                cctx.beginPath();
                cctx.ellipse(x, y, 20 + Math.random() * 40, 10 + Math.random() * 20, Math.random() * Math.PI, 0, Math.PI * 2);
                cctx.fill();
            }

            const cloudTexture = new THREE.CanvasTexture(cloudCanvas);
            const cloudMaterial = new THREE.MeshStandardMaterial({
                map: cloudTexture,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });

            const clouds = new THREE.Mesh(new THREE.SphereGeometry(1.55, 64, 64), cloudMaterial);
            clouds.name = 'clouds';
            group.add(clouds);

            // Atmosphere glow
            const atmosMaterial = new THREE.MeshBasicMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.15,
                side: THREE.BackSide
            });
            const atmosphere = new THREE.Mesh(new THREE.SphereGeometry(1.7, 32, 32), atmosMaterial);
            group.add(atmosphere);

            // Moon
            const moonMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 0.9 });
            const moon = new THREE.Mesh(new THREE.SphereGeometry(0.3, 32, 32), moonMat);
            moon.position.set(3, 0.5, 0);
            moon.name = 'moon';
            group.add(moon);

            group.position.y = 0.5;
            return group;
        }

        function createSolarSystem() {
            const group = new THREE.Group();

            // Sun
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
            const sun = new THREE.Mesh(new THREE.SphereGeometry(0.8, 32, 32), sunMaterial);
            sun.name = 'sun';
            group.add(sun);

            // Sun glow
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.3,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(new THREE.SphereGeometry(1.0, 32, 32), glowMat);
            group.add(glow);

            // Planets
            const planets = [
                { name: 'mercury', color: 0x888888, size: 0.1, distance: 1.5, speed: 0.04 },
                { name: 'venus', color: 0xddaa66, size: 0.15, distance: 2.0, speed: 0.03 },
                { name: 'earthOrbit', color: 0x4488ff, size: 0.16, distance: 2.6, speed: 0.02 },
                { name: 'mars', color: 0xcc4422, size: 0.12, distance: 3.2, speed: 0.015 },
                { name: 'jupiter', color: 0xddaa88, size: 0.4, distance: 4.2, speed: 0.008 },
                { name: 'saturn', color: 0xddcc88, size: 0.35, distance: 5.2, speed: 0.006, hasRings: true },
                { name: 'uranus', color: 0x88dddd, size: 0.25, distance: 6.0, speed: 0.004 },
                { name: 'neptune', color: 0x4466ff, size: 0.24, distance: 6.8, speed: 0.003 }
            ];

            planets.forEach(p => {
                const orbitGroup = new THREE.Group();
                orbitGroup.name = p.name + 'Orbit';

                // Orbit line
                const orbitGeom = new THREE.RingGeometry(p.distance - 0.02, p.distance + 0.02, 64);
                const orbitMat = new THREE.MeshBasicMaterial({ color: 0x333344, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });
                const orbit = new THREE.Mesh(orbitGeom, orbitMat);
                orbit.rotation.x = Math.PI / 2;
                group.add(orbit);

                // Planet
                const planetMat = new THREE.MeshStandardMaterial({ color: p.color, roughness: 0.7 });
                const planet = new THREE.Mesh(new THREE.SphereGeometry(p.size, 16, 16), planetMat);
                planet.position.x = p.distance;
                planet.castShadow = true;
                planet.userData.orbitSpeed = p.speed;
                planet.userData.orbitDistance = p.distance;
                orbitGroup.add(planet);

                // Saturn's rings
                if (p.hasRings) {
                    const ringGeom = new THREE.RingGeometry(p.size * 1.4, p.size * 2.2, 32);
                    const ringMat = new THREE.MeshBasicMaterial({ color: 0xaa9966, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
                    const rings = new THREE.Mesh(ringGeom, ringMat);
                    rings.rotation.x = Math.PI / 3;
                    rings.position.x = p.distance;
                    orbitGroup.add(rings);
                }

                group.add(orbitGroup);
            });

            // Asteroid belt
            const asteroidGeom = new THREE.BufferGeometry();
            const asteroidCount = 500;
            const asteroidPos = new Float32Array(asteroidCount * 3);
            for (let i = 0; i < asteroidCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 3.6 + Math.random() * 0.4;
                asteroidPos[i * 3] = Math.cos(angle) * dist;
                asteroidPos[i * 3 + 1] = (Math.random() - 0.5) * 0.2;
                asteroidPos[i * 3 + 2] = Math.sin(angle) * dist;
            }
            asteroidGeom.setAttribute('position', new THREE.BufferAttribute(asteroidPos, 3));
            const asteroidMat = new THREE.PointsMaterial({ color: 0x666666, size: 0.03 });
            const asteroids = new THREE.Points(asteroidGeom, asteroidMat);
            group.add(asteroids);

            group.position.y = 0;
            group.scale.setScalar(0.8);
            return group;
        }

        function createMicrobes() {
            const group = new THREE.Group();

            // Petri dish
            const dishMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                transmission: 0.9,
                roughness: 0.1,
                thickness: 0.5
            });

            const dish = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 0.3, 64), dishMaterial);
            dish.position.y = -1;
            group.add(dish);

            // Agar medium
            const agarMat = new THREE.MeshStandardMaterial({
                color: 0xeedd99,
                roughness: 0.6,
                transparent: true,
                opacity: 0.8
            });
            const agar = new THREE.Mesh(new THREE.CylinderGeometry(2.4, 2.4, 0.15, 64), agarMat);
            agar.position.y = -0.9;
            group.add(agar);

            // Various microbes
            const microbeTypes = [
                { type: 'bacteria', color: 0x44dd44, count: 30 },
                { type: 'virus', color: 0xdd4444, count: 15 },
                { type: 'amoeba', color: 0x8888dd, count: 8 }
            ];

            microbeTypes.forEach(mt => {
                for (let i = 0; i < mt.count; i++) {
                    let microbe;
                    const mat = new THREE.MeshPhysicalMaterial({
                        color: mt.color,
                        roughness: 0.3,
                        metalness: 0.1,
                        clearcoat: 0.5,
                        transparent: true,
                        opacity: 0.85
                    });

                    if (mt.type === 'bacteria') {
                        // Rod-shaped
                        microbe = new THREE.Group();
                        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.05, 0.15, 8, 16), mat);
                        microbe.add(body);
                        // Flagella
                        const flagMat = new THREE.MeshBasicMaterial({ color: mt.color });
                        for (let f = 0; f < 3; f++) {
                            const flag = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.005, 0.15, 4), flagMat);
                            flag.position.set(-0.1, (f - 1) * 0.03, 0);
                            flag.rotation.z = Math.PI / 2 + (Math.random() - 0.5) * 0.5;
                            microbe.add(flag);
                        }
                    } else if (mt.type === 'virus') {
                        // Spiky ball
                        microbe = new THREE.Group();
                        const core = new THREE.Mesh(new THREE.IcosahedronGeometry(0.08, 0), mat);
                        microbe.add(core);
                        // Spikes
                        const spikeMat = new THREE.MeshBasicMaterial({ color: mt.color });
                        const vertices = core.geometry.attributes.position;
                        for (let v = 0; v < vertices.count; v += 3) {
                            const spike = new THREE.Mesh(new THREE.ConeGeometry(0.015, 0.06, 4), spikeMat);
                            const dir = new THREE.Vector3(vertices.getX(v), vertices.getY(v), vertices.getZ(v)).normalize();
                            spike.position.copy(dir.multiplyScalar(0.08));
                            spike.lookAt(spike.position.clone().multiplyScalar(2));
                            microbe.add(spike);
                        }
                    } else {
                        // Amoeba - blobby shape
                        microbe = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16), mat);
                        // Deform it
                        const pos = microbe.geometry.attributes.position;
                        for (let v = 0; v < pos.count; v++) {
                            const x = pos.getX(v);
                            const y = pos.getY(v);
                            const z = pos.getZ(v);
                            const noise = 1 + Math.sin(x * 5) * 0.2 + Math.cos(z * 5) * 0.2;
                            pos.setXYZ(v, x * noise, y * noise, z * noise);
                        }
                        pos.needsUpdate = true;
                        microbe.geometry.computeVertexNormals();
                    }

                    // Random position in dish
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * 2;
                    microbe.position.set(
                        Math.cos(angle) * dist,
                        -0.7 + Math.random() * 0.5,
                        Math.sin(angle) * dist
                    );
                    microbe.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    microbe.userData.floatSpeed = 0.5 + Math.random();
                    microbe.userData.floatOffset = Math.random() * Math.PI * 2;
                    microbe.name = 'microbe';
                    group.add(microbe);
                }
            });

            group.position.y = 1;
            return group;
        }

        // ============================================
        // ANIME.JS ANIMATIONS
        // ============================================

        function animateCameraTo(preset) {
            const targetPos = CONFIG.camera[preset].position;
            const targetLookAt = CONFIG.camera[preset].target;

            updateStatus('Moving camera...', true);
            isAnimating = true;
            autoRotate = false;

            anime({
                targets: camera.position,
                x: targetPos[0],
                y: targetPos[1],
                z: targetPos[2],
                duration: 1500,
                easing: 'easeInOutQuart',
                update: function () {
                    camera.lookAt(new THREE.Vector3(...targetLookAt));
                    controls.target.set(...targetLookAt);
                },
                complete: function () {
                    isAnimating = false;
                    autoRotate = true;
                    updateStatus('Ready', false);
                }
            });
        }

        function animateLightingTo(preset) {
            const config = CONFIG.lighting[preset];
            updateStatus('Changing lighting...', true);
            isAnimating = true;

            const startBg = { r: scene.background.r, g: scene.background.g, b: scene.background.b };
            const targetBgColor = new THREE.Color(config.background);

            anime({
                targets: startBg,
                r: targetBgColor.r,
                g: targetBgColor.g,
                b: targetBgColor.b,
                duration: 1000,
                easing: 'easeInOutQuad',
                update: function () { scene.background.setRGB(startBg.r, startBg.g, startBg.b); }
            });

            anime({ targets: ambientLight, intensity: config.ambient.intensity, duration: 1000, easing: 'easeInOutQuad' });
            const ambientColor = new THREE.Color(config.ambient.color);
            anime({ targets: ambientLight.color, r: ambientColor.r, g: ambientColor.g, b: ambientColor.b, duration: 1000 });

            anime({ targets: keyLight, intensity: config.key.intensity, duration: 1000, easing: 'easeInOutQuad' });
            anime({ targets: keyLight.position, x: config.key.position[0], y: config.key.position[1], z: config.key.position[2], duration: 1000 });
            const keyColor = new THREE.Color(config.key.color);
            anime({ targets: keyLight.color, r: keyColor.r, g: keyColor.g, b: keyColor.b, duration: 1000 });

            anime({ targets: fillLight, intensity: config.fill.intensity, duration: 1000, easing: 'easeInOutQuad' });
            anime({ targets: fillLight.position, x: config.fill.position[0], y: config.fill.position[1], z: config.fill.position[2], duration: 1000 });
            const fillColor = new THREE.Color(config.fill.color);
            anime({ targets: fillLight.color, r: fillColor.r, g: fillColor.g, b: fillColor.b, duration: 1000 });

            anime({
                targets: rimLight,
                intensity: config.rim.intensity,
                duration: 1000,
                easing: 'easeInOutQuad',
                complete: function () { isAnimating = false; updateStatus('Ready', false); }
            });
            anime({ targets: rimLight.position, x: config.rim.position[0], y: config.rim.position[1], z: config.rim.position[2], duration: 1000 });
            const rimColor = new THREE.Color(config.rim.color);
            anime({ targets: rimLight.color, r: rimColor.r, g: rimColor.g, b: rimColor.b, duration: 1000 });
        }

        function playFullAnimation() {
            if (isAnimating) return;

            updateStatus('Animating...', true);
            isAnimating = true;
            autoRotate = false;

            const timeline = anime.timeline({
                easing: 'easeOutQuad',
                complete: function () {
                    isAnimating = false;
                    autoRotate = true;
                    updateStatus('Ready', false);
                }
            });

            // Scale bounce
            if (currentObject) {
                currentObject.scale.set(0.1, 0.1, 0.1);

                timeline
                    .add({
                        targets: currentObject.scale,
                        x: [0.1, 1.1, 1],
                        y: [0.1, 1.1, 1],
                        z: [0.1, 1.1, 1],
                        duration: 1000,
                        easing: 'easeOutElastic(1, 0.5)'
                    })
                    .add({
                        targets: currentObject.rotation,
                        y: currentObject.rotation.y + Math.PI * 2,
                        duration: 2000,
                        easing: 'easeInOutQuart'
                    }, '-=500')
                    .add({
                        targets: camera.position,
                        x: [camera.position.x, 6, -6, camera.position.x],
                        z: [camera.position.z, 6, 6, camera.position.z],
                        duration: 3000,
                        easing: 'easeInOutQuad',
                        update: function () { camera.lookAt(0, 0, 0); }
                    }, '-=1500');
            }
        }

        function switchObject(type) {
            if (isAnimating) return;

            updateStatus('Loading ' + type + '...', true);
            isAnimating = true;

            // Animate out
            if (currentObject) {
                anime({
                    targets: currentObject.scale,
                    x: 0,
                    y: 0,
                    z: 0,
                    duration: 400,
                    easing: 'easeInQuad',
                    complete: function () {
                        try {
                            createObject(type);
                            if (currentObject) {
                                currentObject.scale.set(0, 0, 0);
                                anime({
                                    targets: currentObject.scale,
                                    x: 1,
                                    y: 1,
                                    z: 1,
                                    duration: 600,
                                    easing: 'easeOutElastic(1, 0.5)',
                                    complete: function () {
                                        isAnimating = false;
                                        updateStatus('Ready', false);
                                    }
                                });
                            }
                        } catch (error) {
                            console.error('Error switching object:', error);
                            isAnimating = false;
                            updateStatus('Error: ' + error.message, false);
                            // Cleanup: ensure loading screen is hidden even on error
                            document.getElementById('loading').classList.add('hidden');
                        }
                    }
                });
            } else {
                try {
                    createObject(type);
                } catch (error) {
                    console.error('Error creating object:', error);
                    updateStatus('Error: ' + error.message, false);
                }
                isAnimating = false;
                updateStatus('Ready', false);
            }
        }

        // ============================================
        // UI CONTROLS
        // ============================================

        function initControls() {
            // Object buttons
            document.querySelectorAll('[data-object]').forEach(function (btn) {
                btn.addEventListener('click', function (e) {
                    if (isAnimating) return;
                    var type = e.target.dataset.object;
                    document.querySelectorAll('[data-object]').forEach(function (b) { b.classList.remove('active'); });
                    e.target.classList.add('active');
                    anime({ targets: e.target, scale: [0.9, 1], duration: 300, easing: 'easeOutElastic(1, 0.5)' });
                    switchObject(type);
                });
            });

            // Camera buttons
            document.querySelectorAll('[data-camera]').forEach(function (btn) {
                btn.addEventListener('click', function (e) {
                    if (isAnimating) return;
                    var preset = e.target.dataset.camera;
                    document.querySelectorAll('[data-camera]').forEach(function (b) { b.classList.remove('active'); });
                    e.target.classList.add('active');
                    anime({ targets: e.target, scale: [0.9, 1], duration: 300, easing: 'easeOutElastic(1, 0.5)' });
                    animateCameraTo(preset);
                });
            });

            // Lighting buttons
            document.querySelectorAll('[data-lighting]').forEach(function (btn) {
                btn.addEventListener('click', function (e) {
                    if (isAnimating) return;
                    var preset = e.target.dataset.lighting;
                    document.querySelectorAll('[data-lighting]').forEach(function (b) { b.classList.remove('active'); });
                    e.target.classList.add('active');
                    anime({ targets: e.target, scale: [0.9, 1], duration: 300, easing: 'easeOutElastic(1, 0.5)' });
                    animateLightingTo(preset);
                });
            });

            // Play button
            document.getElementById('play-btn').addEventListener('click', function (e) {
                if (!isAnimating) {
                    anime({ targets: e.target, scale: [0.85, 1], duration: 400, easing: 'easeOutElastic(1, 0.5)' });
                    playFullAnimation();
                }
            });
        }

        function showUI() {
            anime({ targets: '#control-panel', translateY: [50, 0], opacity: [0, 1], duration: 800, delay: 200, easing: 'easeOutQuart' });
            anime({ targets: '#info-panel', translateX: [-50, 0], opacity: [0, 1], duration: 800, delay: 100, easing: 'easeOutQuart' });
            anime({ targets: '#indicator', translateX: [50, 0], opacity: [0, 1], duration: 800, delay: 150, easing: 'easeOutQuart' });
        }

        function updateStatus(text, animating) {
            document.getElementById('status-text').textContent = text;
            var dot = document.getElementById('status-dot');
            if (animating) { dot.classList.add('animating'); }
            else { dot.classList.remove('animating'); }
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsed = clock.getElapsedTime();

            // Auto rotation
            if (autoRotate && currentObject && !isAnimating) {
                currentObject.rotation.y += 0.003;
            }

            // Object-specific animations
            if (currentObject) {
                // Crystal ball particles
                const particles = currentObject.getObjectByName('particles');
                if (particles) {
                    particles.rotation.y += 0.005;
                    particles.rotation.x += 0.002;
                }

                // Earth rotation
                const earth = currentObject.getObjectByName('earth');
                if (earth) { earth.rotation.y += 0.002; }
                const clouds = currentObject.getObjectByName('clouds');
                if (clouds) { clouds.rotation.y += 0.0025; }
                const moon = currentObject.getObjectByName('moon');
                if (moon) {
                    const moonAngle = elapsed * 0.3;
                    moon.position.x = Math.cos(moonAngle) * 3;
                    moon.position.z = Math.sin(moonAngle) * 3;
                }

                // Solar system orbits
                if (currentObjectType === 'solar') {
                    currentObject.children.forEach(child => {
                        if (child.name && child.name.includes('Orbit') && child.children[0]) {
                            const planet = child.children[0];
                            if (planet.userData.orbitSpeed) {
                                child.rotation.y += planet.userData.orbitSpeed;
                            }
                        }
                    });
                    const sun = currentObject.getObjectByName('sun');
                    if (sun) { sun.rotation.y += 0.01; }
                }

                // Microbes floating
                if (currentObjectType === 'microbes') {
                    currentObject.children.forEach(child => {
                        if (child.name === 'microbe') {
                            child.position.y += Math.sin(elapsed * child.userData.floatSpeed + child.userData.floatOffset) * 0.001;
                            child.rotation.x += 0.005;
                            child.rotation.z += 0.003;
                        }
                    });
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        function init() {
            try {
                initThreeJS();
                initControls();

                setTimeout(function () {
                    document.getElementById('loading').classList.add('hidden');
                    showUI();
                }, 800);

                animate();
                console.log('üåü 3D Object Viewer Initialized');
            } catch (error) {
                console.error('Initialization error:', error);
                document.querySelector('.loading-text').textContent = 'Error: ' + error.message;
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>

</html>