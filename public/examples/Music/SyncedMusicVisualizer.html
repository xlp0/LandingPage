<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Synchronized Music Sheet & Waveform Visualizer</title>
    <!-- OSMD Library -->
    <script src="https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@1.8.6/build/opensheetmusicdisplay.min.js"></script>
    <!-- Tone.js for audio synthesis -->
    <script src="https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.min.js"></script>
    <!-- Redux (plain) -->
    <script src="https://cdn.jsdelivr.net/npm/redux@4.2.1/dist/redux.min.js"></script>

    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Instrument+Sans:wght@400;500;600&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Instrument Sans', -apple-system, sans-serif;
            background: linear-gradient(135deg, #0a0e14 0%, #1a222d 100%);
            color: #e6edf3;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            font-weight: 600;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #00d4ff, #ff7b00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #8b949e;
            font-size: 1.1em;
        }

        /* Song Selector */
        .song-selector {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 24px;
        }

        .song-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Instrument Sans', sans-serif;
            font-size: 14px;
            font-weight: 500;
        }

        .song-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .song-btn.active {
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            border-color: #00d4ff;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.4);
        }

        /* Split Panel Layout */
        .panels {
            display: grid;
            grid-template-rows: auto 300px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: rgba(18, 24, 32, 0.6);
            border: 1px solid #2a3544;
            border-radius: 12px;
            overflow: hidden;
        }

        .panel-header {
            padding: 16px 20px;
            background: rgba(26, 34, 45, 0.8);
            border-bottom: 1px solid #2a3544;
            font-size: 14px;
            font-weight: 500;
            color: #8b949e;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Music Sheet Panel */
        .music-sheet-panel {
            min-height: 400px;
        }

        #osmd-container {
            padding: 30px;
            background: #fff;
            min-height: 350px;
            overflow-x: auto;
        }

        /* Waveform Panel */
        .waveform-panel {
            position: relative;
        }

        .waveform-canvas-container {
            height: 220px;
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #waveform-canvas {
            width: 100%;
            height: 100%;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 16px;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: rgba(26, 34, 45, 0.6);
            border-radius: 12px;
            flex-wrap: wrap;
        }

        .transport-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .transport-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .play-btn {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #ff7b00, #e94560);
            border-color: #ff7b00;
        }

        .play-btn:hover {
            box-shadow: 0 4px 15px rgba(255, 123, 0, 0.4);
        }

        .transport-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* Time Display */
        .time-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-left: 20px;
            padding-left: 20px;
            border-left: 1px solid rgba(255, 255, 255, 0.2);
        }

        .time-current {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-weight: 500;
            color: #00d4ff;
        }

        .time-total {
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            color: #8b949e;
        }

        /* Status */
        .status-bar {
            padding: 12px 20px;
            background: rgba(26, 34, 45, 0.4);
            border-radius: 8px;
            text-align: center;
            color: #8b949e;
            font-size: 13px;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #484f58;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>ðŸŽ¼ Synchronized Music Visualizer</h1>
            <div class="subtitle">Sheet Music + Real-time Waveform</div>
        </header>

        <!-- Song Selector -->
        <div class="song-selector" id="songSelector">
            <!-- Will be populated by JavaScript -->
        </div>

        <!-- Status Bar -->
        <div class="status-bar" id="statusBar">Select a song to begin</div>

        <!-- Split Panels -->
        <div class="panels">
            <!-- Music Sheet Panel -->
            <div class="panel music-sheet-panel">
                <div class="panel-header">ðŸ“„ Music Sheet</div>
                <div id="osmd-container">
                    <div class="empty-state">
                        <div class="empty-state-icon">ðŸŽµ</div>
                        <div>Music sheet will appear here</div>
                    </div>
                </div>
            </div>

            <!-- Waveform Panel -->
            <div class="panel waveform-panel">
                <div class="panel-header">ðŸŒŠ Audio Waveform</div>
                <div class="waveform-canvas-container">
                    <canvas id="waveform-canvas"></canvas>
                </div>
            </div>
        </div>

        <!-- Playback Controls -->
        <div class="controls">
            <button class="transport-btn" id="stopBtn" title="Stop">
                <svg viewBox="0 0 24 24">
                    <rect x="6" y="6" width="12" height="12" />
                </svg>
            </button>
            <button class="transport-btn play-btn" id="playBtn" title="Play/Pause" disabled>
                <svg viewBox="0 0 24 24" id="play-icon">
                    <polygon points="8 5 19 12 8 19 8 5" />
                </svg>
                <svg viewBox="0 0 24 24" id="pause-icon" style="display:none;">
                    <rect x="6" y="4" width="4" height="16" />
                    <rect x="14" y="4" width="4" height="16" />
                </svg>
            </button>
            <div class="time-info">
                <div class="time-current" id="currentTime">00:00</div>
                <div class="time-total">/ <span id="totalTime">00:00</span></div>
            </div>
        </div>
    </div>

    <!-- Load Songs Data -->
    <script src="./songs-data.js"></script>

    <script>
        // --- REDUX STORE SETUP (Plain Redux) ---
        const { createStore, combineReducers } = Redux;

        // Action Types
        const ActionTypes = {
            SET_STATUS: 'SET_STATUS',
            SET_PLAYING: 'SET_PLAYING',
            SET_TIME: 'SET_TIME',
            SET_DURATION: 'SET_DURATION',
            RESET_PLAYBACK: 'RESET_PLAYBACK',
            START_LOADING: 'START_LOADING',
            SONG_LOADED: 'SONG_LOADED',
            LOAD_ERROR: 'LOAD_ERROR'
        };

        // Action Creators
        const setStatus = (status) => ({ type: ActionTypes.SET_STATUS, payload: status });
        const setPlaying = (isPlaying) => ({ type: ActionTypes.SET_PLAYING, payload: isPlaying });
        const setTime = (time) => ({ type: ActionTypes.SET_TIME, payload: time });
        const setDuration = (duration) => ({ type: ActionTypes.SET_DURATION, payload: duration });
        const resetPlayback = () => ({ type: ActionTypes.RESET_PLAYBACK });
        const startLoading = (data) => ({ type: ActionTypes.START_LOADING, payload: data });
        const songLoaded = (data) => ({ type: ActionTypes.SONG_LOADED, payload: data });
        const loadError = (error) => ({ type: ActionTypes.LOAD_ERROR, payload: error });

        // Playback Reducer
        const playbackInitialState = {
            isPlaying: false,
            currentTime: 0,
            duration: 0,
            status: 'Ready'
        };

        function playbackReducer(state = playbackInitialState, action) {
            switch (action.type) {
                case ActionTypes.SET_STATUS:
                    return { ...state, status: action.payload };
                case ActionTypes.SET_PLAYING:
                    return { ...state, isPlaying: action.payload };
                case ActionTypes.SET_TIME:
                    return { ...state, currentTime: action.payload };
                case ActionTypes.SET_DURATION:
                    return { ...state, duration: action.payload };
                case ActionTypes.RESET_PLAYBACK:
                    return { ...state, isPlaying: false, currentTime: 0, status: 'Ready' };
                default:
                    return state;
            }
        }

        // Song Reducer
        const songInitialState = {
            currentSongId: null,
            title: 'No Song Selected',
            composer: '',
            isLoading: false,
            error: null
        };

        function songReducer(state = songInitialState, action) {
            switch (action.type) {
                case ActionTypes.START_LOADING:
                    return { ...state, isLoading: true, error: null, title: action.payload.title };
                case ActionTypes.SONG_LOADED:
                    return { ...state, isLoading: false, currentSongId: action.payload.id, title: action.payload.title, composer: action.payload.composer };
                case ActionTypes.LOAD_ERROR:
                    return { ...state, isLoading: false, error: action.payload, title: 'Error Loading Song' };
                default:
                    return state;
            }
        }

        // Combined Store
        const rootReducer = combineReducers({
            playback: playbackReducer,
            song: songReducer
        });

        const store = createStore(rootReducer);


        // --- AUDIO & LOGIC ENGINE (Non-UI) ---
        class AudioEngine {
            constructor(store) {
                this.store = store;
                this.osmd = null;
                this.synth = null;
                this.analyser = null;
                this.allNotes = [];
                this.currentNoteIndex = 0;
                this.animationId = null;

                // Subscribe to store changes
                this.unsubscribe = store.subscribe(() => this.handleStateChange());
                this.lastState = store.getState();
            }

            async init() {
                // Audio setup deferred until user gesture (see initAudio)
                this.audioInitialized = false;
            }

            async initAudio() {
                if (this.audioInitialized) return;
                try {
                    await Tone.start();
                    console.log("Tone.js started, state:", Tone.context.state);
                    
                    // Use Tone.js FFT for analysis
                    this.fft = new Tone.FFT(64);
                    
                    // Create synth and connect to both FFT and destination
                    this.synth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.5 },
                        volume: -6
                    });
                    
                    // Chain: synth -> fft -> destination
                    this.synth.connect(this.fft);
                    this.synth.toDestination();
                    
                    this.audioInitialized = true;
                    console.log("Audio initialized successfully, synth ready");
                } catch (e) {
                    console.warn("Audio initialization failed:", e);
                }
            }

            handleStateChange() {
                const state = this.store.getState();
                const prev = this.lastState;
                this.lastState = state;

                if (state.playback.isPlaying !== prev.playback.isPlaying) {
                    if (state.playback.isPlaying) {
                        this.startInternalPlayback();
                    } else {
                        this.pauseInternalPlayback();
                    }
                }
            }

            async loadSong(songId) {
                const song = SONGS_DATA[songId];
                if (!song) return;

                this.store.dispatch(startLoading({ title: song.title }));
                this.store.dispatch(setStatus('Loading...'));
                this.stop();

                try {
                    if (!this.osmd) {
                        this.osmd = new opensheetmusicdisplay.OpenSheetMusicDisplay('osmd-container', {
                            autoResize: true,
                            backend: 'svg',
                            drawingParameters: 'compact'
                        });
                    }

                    await this.osmd.load(song.xml);
                    await this.osmd.render();

                    this.osmd.cursor.show();
                    this.osmd.cursor.reset();

                    this.allNotes = this.extractNotes();
                    this.currentNoteIndex = 0;

                    const estimatedDuration = this.allNotes.length * 0.5;

                    this.store.dispatch(songLoaded({
                        id: songId,
                        title: song.title,
                        composer: song.composer
                    }));
                    this.store.dispatch(setDuration(estimatedDuration));
                    this.store.dispatch(setTime(0));
                    this.store.dispatch(setStatus('Ready'));
                } catch (err) {
                    console.error("Error loading song:", err);
                    this.store.dispatch(loadError(err.message));
                }
            }

            async togglePlay() {
                // Initialize audio on first user gesture
                await this.initAudio();

                const state = this.store.getState();
                if (state.playback.isPlaying) {
                    this.store.dispatch(setPlaying(false));
                    this.store.dispatch(setStatus('Paused'));
                } else {
                    if (state.song.currentSongId) {
                        this.store.dispatch(setPlaying(true));
                        this.store.dispatch(setStatus('Playing'));
                    }
                }
            }

            stop() {
                this.store.dispatch(resetPlayback());
                this.pauseInternalPlayback();
                this.currentNoteIndex = 0;
                if (this.osmd && this.osmd.cursor) {
                    this.osmd.cursor.reset();
                }
            }

            // --- Internal Audio/Music Logic ---

            startInternalPlayback() {
                if (this.currentNoteIndex >= this.allNotes.length) {
                    this.currentNoteIndex = 0;
                    if (this.osmd) this.osmd.cursor.reset();
                }
                this.playNextNote();
                this.startClock();
            }

            pauseInternalPlayback() {
                if (this.playbackTimeout) clearTimeout(this.playbackTimeout);
                if (this.clockTimer) clearInterval(this.clockTimer);
            }

            playNextNote() {
                const state = this.store.getState();
                if (!state.playback.isPlaying) return;

                if (this.currentNoteIndex >= this.allNotes.length) {
                    this.store.dispatch(setPlaying(false));
                    this.store.dispatch(setStatus('Finished'));
                    return;
                }

                const noteData = this.allNotes[this.currentNoteIndex];

                // Play notes (if synth available and notes exist)
                if (this.synth && noteData.notes && noteData.notes.length > 0) {
                    try {
                        const now = Tone.now();
                        noteData.notes.forEach(pitch => {
                            this.synth.triggerAttackRelease(pitch, "8n", now);
                        });
                    } catch (e) {
                        console.warn("Synth trigger failed:", e);
                    }
                }

                // Advance OSMD cursor
                if (this.osmd) {
                    this.osmd.cursor.next();
                }

                this.currentNoteIndex++;

                // Tick the store time immediately for better responsiveness
                if (this.currentNoteIndex % 2 === 0) {
                    this.store.dispatch(setTime(this.currentNoteIndex * 0.5));
                }

                // Schedule next note
                this.playbackTimeout = setTimeout(() => this.playNextNote(), 500);
            }

            startClock() {
                if (this.clockTimer) clearInterval(this.clockTimer);
                this.clockTimer = setInterval(() => {
                    const time = this.currentNoteIndex * 0.5;
                    this.store.dispatch(setTime(time));
                }, 500); // Sync rhythm with playNextNote
            }

            extractNotes() {
                this.allNotes = [];
                if (!this.osmd || !this.osmd.cursor) return [];
                this.osmd.cursor.reset();
                while (!this.osmd.cursor.Iterator.EndReached) {
                    const voices = this.osmd.cursor.VoicesUnderCursor();
                    let notesAtPosition = [];
                    for (const voice of voices) {
                        for (const note of voice.Notes) {
                            if (!note.isRest() && note.Pitch) {
                                const pitch = note.Pitch;
                                const noteNames = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
                                const noteName = noteNames[pitch.FundamentalNote % 7];
                                // OSMD octave needs +3 offset for standard notation (C4 = middle C)
                                let accidental = '';
                                if (pitch.Accidental === 1) accidental = '#';
                                else if (pitch.Accidental === -1) accidental = 'b';
                                const octave = pitch.Octave + 3;
                                notesAtPosition.push(noteName + accidental + octave);
                            }
                        }
                    }
                    if (notesAtPosition.length > 0) {
                        this.allNotes.push({ notes: notesAtPosition, duration: 0.5 });
                    }
                    this.osmd.cursor.next();
                }
                this.osmd.cursor.reset();
                console.log("Extracted notes:", this.allNotes.slice(0, 5));
                return this.allNotes;
            }

            getFFT() {
                return this.fft;
            }
        }


        // --- UI MANAGER (Purely Reactive) ---
        class UIManager {
            constructor(store, audioEngine) {
                this.store = store;
                this.audioEngine = audioEngine;
                this.canvas = document.getElementById('waveform-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.animationLoop = null;

                // DOM Elements
                this.elSongSelector = document.getElementById('songSelector');
                this.elStatusBar = document.getElementById('statusBar');
                this.elPlayBtn = document.getElementById('playBtn');
                this.elStopBtn = document.getElementById('stopBtn');
                this.elTimeCurrent = document.getElementById('currentTime');
                this.elTimeTotal = document.getElementById('totalTime');
                this.playIcon = document.getElementById('play-icon');
                this.pauseIcon = document.getElementById('pause-icon');

                // Subscribe
                this.store.subscribe(() => this.render());

                // Init
                this.setupCanvas();
                this.initSongList();
                this.bindEvents();
                this.startWaveformLoop();
            }

            setupCanvas() {
                const container = this.canvas.parentElement;
                const dpr = window.devicePixelRatio || 1;
                const resize = () => {
                    this.canvas.width = container.clientWidth * dpr;
                    this.canvas.height = container.clientHeight * dpr;
                    this.canvas.style.width = container.clientWidth + 'px';
                    this.canvas.style.height = container.clientHeight + 'px';
                    this.ctx.scale(dpr, dpr);
                };
                window.addEventListener('resize', resize);
                resize();
            }

            initSongList() {
                Object.keys(SONGS_DATA).forEach(key => {
                    const song = SONGS_DATA[key];
                    const btn = document.createElement('button');
                    btn.className = 'song-btn';
                    btn.textContent = song.title;
                    btn.onclick = () => {
                        if (this.audioEngine) {
                            this.audioEngine.loadSong(key);
                        } else {
                            console.error("AudioEngine NOT initialized");
                            alert("Audio system failed to initialize. Please check your browser's audio settings.");
                        }
                    };
                    this.elSongSelector.appendChild(btn);
                });
            }

            bindEvents() {
                this.elPlayBtn.onclick = () => this.audioEngine.togglePlay();
                this.elStopBtn.onclick = () => this.audioEngine.stop();
            }

            // Main Render Loop (Reactive)
            render() {
                const state = this.store.getState();
                const { playback, song } = state;

                // 1. Status Bar
                if (song.isLoading) {
                    this.elStatusBar.textContent = `Loading "${song.title}"...`;
                } else if (song.error) {
                    this.elStatusBar.textContent = `Error: ${song.error}`;
                } else if (playback.isPlaying) {
                    this.elStatusBar.textContent = `Playing: "${song.title}"`;
                } else if (song.currentSongId) {
                    this.elStatusBar.textContent = `Ready: "${song.title}" by ${song.composer || 'Unknown'}`;
                } else {
                    this.elStatusBar.textContent = 'Select a song to begin';
                }

                // 2. Play Button State
                this.elPlayBtn.disabled = !song.currentSongId || song.isLoading;
                if (playback.isPlaying) {
                    this.playIcon.style.display = 'none';
                    this.pauseIcon.style.display = 'block';
                } else {
                    this.playIcon.style.display = 'block';
                    this.pauseIcon.style.display = 'none';
                }

                // 3. Time Display
                this.elTimeCurrent.textContent = this.formatTime(playback.currentTime);
                this.elTimeTotal.textContent = this.formatTime(playback.duration);

                // 4. Song Buttons Selection
                Array.from(this.elSongSelector.children).forEach(btn => {
                    const isSelected = btn.textContent === song.title;
                    btn.classList.toggle('active', isSelected);
                });
            }

            formatTime(seconds) {
                const min = Math.floor(seconds / 60).toString().padStart(2, '0');
                const sec = Math.floor(seconds % 60).toString().padStart(2, '0');
                return `${min}:${sec}`;
            }

            // Waveform uses high-frequency loop (separate from Redux state updates)
            startWaveformLoop() {
                const animate = () => {
                    this.drawWaveform();
                    requestAnimationFrame(animate);
                };
                animate();
            }

            drawWaveform() {
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;
                const fft = this.audioEngine.getFFT();

                this.ctx.fillStyle = '#0a0e14';
                this.ctx.fillRect(0, 0, width, height);

                if (!fft) return;

                // Tone.js FFT returns values in dB (-Infinity to 0)
                const values = fft.getValue();
                const barCount = values.length;
                const barWidth = width / barCount;

                for (let i = 0; i < barCount; i++) {
                    // Convert dB to 0-1 range (dB values are typically -100 to 0)
                    const db = values[i];
                    const value = Math.max(0, (db + 100) / 100);
                    const barHeight = value * height * 0.8;

                    const hue = 180 + (value * 60);
                    this.ctx.fillStyle = `hsla(${hue}, 70%, 60%, 0.8)`;
                    this.ctx.fillRect(i * barWidth, height - barHeight, barWidth - 2, barHeight);
                }
            }
        }

        // --- BOOTSTRAP ---
        async function bootstrap() {
            if (window.app) return; // Prevent double init

            const audioEngine = new AudioEngine(store);
            await audioEngine.init();

            const uiManager = new UIManager(store, audioEngine);

            // Expose for debugging
            window.app = { store, audioEngine, uiManager };
            console.log("App Bootstrapped Successfully");
        }

        // Handle bothDOMContentLoaded and cases where script runs after it fired
        if (document.readyState === 'loading') {
            window.addEventListener('DOMContentLoaded', bootstrap);
        } else {
            bootstrap();
        }
    </script>
</body>

</html>