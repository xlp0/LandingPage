# Action Monad Multiplication - Church Numeral Multiplication
#
# Demonstrates multiplication using Church numeral encoding.
# Uses the Lambda engine in PTR to perform pure functional arithmetic.
#
# Church Multiplication:
#   MULT = λm.λn.λf.m (n f)
#   (m × n) applies n f, then applies that m times
#
# This is action composition at its core:
#   multiply(2, 3) = (λf.λx.f(f x)) applied to (λf.λx.f(f(f x))) 
#                 = 6 applications

chapter:
  id: "prologue_action_multiply"
  title: "Multiplication with Action Monad"
  mvp_card: "The Multiplier"
  pkc_task: "Demonstrate Functional Arithmetic"

clm:
  abstract:
    concept: "Church Numeral Multiplication"
    specification: |
      Implements multiplication via function composition:
      
      Church Numerals:
        0 = λf.λx.x
        1 = λf.λx.f x
        2 = λf.λx.f (f x)
        n = λf.λx.f^n x
        
      Multiplication:
        MULT = λm.λn.λf.m (n f)
        
      Each multiplication is an Action[int] that:
      1. Encodes operands as Church numerals
      2. Applies MULT via beta reduction  
      3. Decodes result back to integer
      4. Logs the lambda expression trace
      
    inputs:
      a: { type: "int", description: "First operand" }
      b: { type: "int", description: "Second operand" }
    outputs:
      product: { type: "int" }
      church_trace: { type: "string", description: "Lambda expression trace" }
      
  concrete:
    runtime: lambda
    operation: normalize
    strategy: normal
    maxSteps: 200
    
  balanced:
    description: "Verify Church multiplication produces correct results."
    test_cases:
      - given: "2 × 3 = 6"
        when:
          # MULT 2 3 = (λm.λn.λf.m (n f)) (λf.λx.f (f x)) (λf.λx.f (f (f x)))
          expression: "(\\m.\\n.\\f.m (n f)) (\\f.\\x.f (f x)) (\\f.\\x.f (f (f x)))"
        then:
          success: true
          
      - given: "1 × 5 = 5"
        when:
          # MULT 1 5
          expression: "(\\m.\\n.\\f.m (n f)) (\\f.\\x.f x) (\\f.\\x.f (f (f (f (f x)))))"
        then:
          success: true
          
      - given: "0 × 3 = 0"
        when:
          # MULT 0 3 = 0 (zero annihilates)
          expression: "(\\m.\\n.\\f.m (n f)) (\\f.\\x.x) (\\f.\\x.f (f (f x)))"
        then:
          success: true

examples:
  - name: "2 × 2 = 4"
    description: "MULT TWO TWO"
    input:
      expression: "(\\m.\\n.\\f.m (n f)) (\\f.\\x.f (f x)) (\\f.\\x.f (f x))"
    expected_output: "(λf.(λx.(f (f (f (f x))))))"
      
  - name: "3 × 1 = 3"
    description: "MULT THREE ONE (identity)"
    input:
      expression: "(\\m.\\n.\\f.m (n f)) (\\f.\\x.f (f (f x))) (\\f.\\x.f x)"
    expected_output: "(λf.(λx.(f (f (f x)))))"
      
  - name: "0 × anything = 0"
    description: "Zero annihilation property"
    input:
      expression: "(\\m.\\n.\\f.m (n f)) (\\f.\\x.x) (\\f.\\x.f (f x))"
    expected_output: "(λf.(λx.x))"
