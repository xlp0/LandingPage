# IO Monad Demo - Observable Effects in Pure Lambda Calculus
#
# This CLM demonstrates the IO Monad pattern for side effects in pure computation.
# The IO Monad allows us to observe computation steps without polluting the pure logic.
#
# Key Concept:
#   IO a = World → (a, World')
#
# In CLM context:
#   Reduction = TermHash → (TermHash', IOEffects)
#
# IO effects are purely observational - they do not affect computation results.
# The same input always produces the same output regardless of IO configuration.

version: '1.1'

chapter:
  id: 909
  title: 'IO Monad Demo - Observable Effects'
  mvp_card: 'The IO Monad Pattern'
  pkc_task: 'Demonstrate configurable IO effects in CLM'

clm:
  abstract_spec:
    context: "IO Monad Pattern for Observable Side Effects"
    goal: "Show how to enable/configure IO effects in lambda computations."
    success_criteria: "Computation completes with observable console output when io_effects.enabled is true."

  concrete_impl:
    runtime: lambda
    builtin: true
    inputs: ["expression"]
    process: "normalize"
    outputs: ["result", "reductionPath"]
    
    # IO Monad Configuration
    # Toggle this to enable/disable IO effects
    io_effects:
      enabled: true           # Master toggle: set to false to disable all IO
      console: true           # Print to terminal
      on_step: true           # Log each reduction step (verbose mode)
      on_complete: true       # Log final result
      format: "verbose"       # "minimal" | "verbose" | "json"
    
    description: |
      ## IO Monad Pattern in CLM
      
      The io_effects configuration enables observable side effects:
      
      ### Configuration Options:
      - `enabled`: Master toggle (default: false)
      - `console`: Print to terminal (default: true when enabled)
      - `on_step`: Log each reduction step (default: false)
      - `on_complete`: Log final result (default: true)
      - `format`: Output format - "minimal", "verbose", or "json"
      
      ### Network Output (Optional):
      ```yaml
      io_effects:
        network:
          enabled: true
          endpoint: "http://localhost:3000/log"
          method: "POST"
      ```
      
      ### Usage:
      Enable step-by-step logging to see the reduction trace in real-time.
      Disable for silent execution (computation result is unchanged).

  balanced_exp:
    expectation: "Computations complete with IO effects visible in console."
    test_cases:
      # Test 1: Simple successor function with IO logging
      - given: "Successor of ONE = TWO (with IO logging)"
        when:
          arguments:
            # SUCC 1 = (λn.λf.λx.f (n f x)) (λf.λx.f x) → λf.λx.f (f x)
            expression: "(\\n.\\f.\\x.f (n f x)) (\\f.\\x.f x)"
        then:
          result: "(λf.(λx.(f (f x))))"

      # Test 2: Identity function (minimal steps - shows IO still fires)
      - given: "Identity applied to variable (1 step)"
        when:
          arguments:
            # I x = (λx.x) y → y
            expression: "(\\x.x) y"
        then:
          result: "y"

      # Test 3: Boolean logic with IO tracing
      - given: "TRUE applied to two arguments"
        when:
          arguments:
            # TRUE a b = (λx.λy.x) a b → a
            expression: "(\\x.\\y.x) a b"
        then:
          result: "a"

examples:
  - name: "SUCC 1 = 2 (With IO Trace)"
    description: "Watch each reduction step printed to console"
    input:
      expression: "(\\n.\\f.\\x.f (n f x)) (\\f.\\x.f x)"
    expected_output: "(λf.(λx.(f (f x))))"

  - name: "Identity (I x = x)"
    description: "Single-step reduction with IO"
    input:
      expression: "(\\x.x) y"
    expected_output: "y"

  - name: "TRUE a b = a"
    description: "Boolean selection with IO logging"
    input:
      expression: "(\\x.\\y.x) a b"
    expected_output: "a"
