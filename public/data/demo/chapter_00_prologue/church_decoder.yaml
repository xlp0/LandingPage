# Human-Readable Arithmetic with Church Numeral Decoding
#
# This CLM demonstrates complex Church numeral arithmetic with
# automatic decoding to human-readable integers.
#
# The `church-to-int` operation:
# 1. Normalizes the Church numeral expression
# 2. Decodes the λf.λx.f^n(x) structure to integer n
# 3. Returns the integer alongside the lambda form
#
# This makes it easy for humans to verify arithmetic results!

version: '1.1'

chapter:
  id: 909
  title: 'Human-Readable Church Arithmetic'
  mvp_card: 'The Decoder'
  pkc_task: 'Convert Lambda to Integer'

clm:
  abstract_spec:
    context: "Church Numeral Decoding for Human Readability"
    goal: "Perform arithmetic and decode results to regular integers."
    success_criteria: "Church numerals decode to correct integer values."

  concrete_impl:
    runtime: lambda
    builtin: true
    inputs: ["expression"]
    process: "church-to-int"  # Special operation that decodes to integer
    outputs: ["integer", "church_form"]
    description: |
      Church Numerals:
        0 = λf.λx.x           → decodes to 0
        1 = λf.λx.f x         → decodes to 1
        2 = λf.λx.f (f x)     → decodes to 2
        n = λf.λx.f^n(x)      → decodes to n
      
      The church-to-int operation counts applications of f to x.

  balanced_exp:
    expectation: "Arithmetic results decode to correct integers."
    test_cases:
      # ZERO = λf.λx.x
      - given: "ZERO decodes to 0"
        when:
          arguments:
            expression: "(\\f.\\x.x)"
        then:
          result_contains: "0 (Church:"

      # ONE = λf.λx.f x
      - given: "ONE decodes to 1"
        when:
          arguments:
            expression: "(\\f.\\x.f x)"
        then:
          result_contains: "1 (Church:"

      # TWO = λf.λx.f (f x)
      - given: "TWO decodes to 2"
        when:
          arguments:
            expression: "(\\f.\\x.f (f x))"
        then:
          result_contains: "2 (Church:"

      # 2 + 2 = 4
      - given: "Addition 2 + 2 = 4"
        when:
          arguments:
            # ADD 2 2
            expression: "(\\m.\\n.\\f.\\x.m f (n f x)) (\\f.\\x.f (f x)) (\\f.\\x.f (f x))"
        then:
          result_contains: "4 (Church:"

      # 2 × 3 = 6
      - given: "Multiplication 2 × 3 = 6"
        when:
          arguments:
            # MULT 2 3
            expression: "(\\m.\\n.\\f.m (n f)) (\\f.\\x.f (f x)) (\\f.\\x.f (f (f x)))"
        then:
          result_contains: "6 (Church:"

examples:
  - name: "Zero"
    description: "Church ZERO decodes to 0"
    input:
      expression: "(\\f.\\x.x)"
    result_contains: "0 (Church:"

  - name: "One"
    description: "Church ONE decodes to 1"
    input:
      expression: "(\\f.\\x.f x)"
    result_contains: "1 (Church:"

  - name: "Two"
    description: "Church TWO decodes to 2"
    input:
      expression: "(\\f.\\x.f (f x))"
    result_contains: "2 (Church:"

  - name: "Three"
    description: "Church THREE decodes to 3"
    input:
      expression: "(\\f.\\x.f (f (f x)))"
    result_contains: "3 (Church:"

  - name: "2 + 2 = 4"
    description: "Church addition decodes correctly"
    input:
      expression: "(\\m.\\n.\\f.\\x.m f (n f x)) (\\f.\\x.f (f x)) (\\f.\\x.f (f x))"
    result_contains: "4 (Church:"

  - name: "2 × 3 = 6"
    description: "Church multiplication decodes correctly"
    input:
      expression: "(\\m.\\n.\\f.m (n f)) (\\f.\\x.f (f x)) (\\f.\\x.f (f (f x)))"
    result_contains: "6 (Church:"

  - name: "SUCC 2 = 3"
    description: "Successor function"
    input:
      expression: "(\\n.\\f.\\x.f (n f x)) (\\f.\\x.f (f x))"
    result_contains: "3 (Church:"
